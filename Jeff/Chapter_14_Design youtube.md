## CHAPTER 14: DESIGN YOUTUBE

```
논의내용)
속도 최적화를 위해 업로드, 다운로드, 인코딩의 각 단계에 모두 메시지 큐를 넣어 설계하는 부분이 상당히 인상적이네요. 앞선 챕터들에서 이미 그런 방식의 설계를 지향했는데 비디오 전송이다 보니 더 극에 달한 것 같습니다.

책에는 언급이 되어 있지 않지만 앞서 설계했던 기능들의 일부를 여기서 모두 축약시키면 정말 유튜브 시스템이 될 것 같습니다.
유튜브도 URL 단축으로 링크를 만들고, 알림 시스템을 통해 구독한 채널 영상이 업로드가 완료 됐다는 걸 알려줍니다.
또 피드 시스템을 통해서 최근 영상 순서대로 목록을 확인할 수 있으며, 라이브 방송의 경우는 채팅 기능도 들어 있습니다.
유튜브도 비디오 검색을 지원하므로 검색어 자동 완성도 되야 한다고 보면 거의 끝판왕 급의 설계이지 않을까 생각을 해 보게 되네요.
```

<img width="1111" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ee30fd96-15d9-465f-a49e-1f7825c4842f">

이 문제는 넷플릭스나 훌루 같은 비디오 플랫폼을 설계하는 문제에도 적용 가능하다.
유튜브는 간단해 보이지만 복잡한 수많은 기술이 숨어 있다.
2020년에 조사한 유튜브에 대한 통계 자료 몇 가지를 살펴본다.

- 월간 능동 사용자 수: 20억
- 매일 재생되는 비디오 수: 50억
- 미국 성인 가운데 73%가 유튜브 이용
- 5천만명의 창장작
- 유튜브의 광고 수입은 2019년 기준 150억 달러이며 이는 2018년도 대비 36% 증가한 수치
- 모바일 인터넷 트래픽에서 37%가 유튜브
- 80개 언어로 이용 가능

### 1단계 문제 이해 및 설계 범위 확정

유튜브는 비디오 시청 외에 댓글 달기, 비디오 공유, 좋아요, 재생 목록 저장, 채널 구독 기능들이 있다.
면접관과 대화를 통해 설계 범위를 좁혀야 한다.
여기서는 아래와 같은 기능을 가지는 비디오 스트리밍 서비스 설계에 초점을 둔다.

- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용
- 높은 가용성과 규모 확장성, 그리고 안정성
- 지원 클라이언트: 모바일 웹, 웹 브라우저, 그리고 스마트 TV

#### 개략적 규모 추정

아래 추정치는 많은 것을 가정한 것이다.

- 일간 능동 사용자(DAU): 5백만
- 한 사용자가 하루에 평균 5개의 비디오 시청
- 10%의 사용자가 하루에 1비디오 업로드
- 비디오 평균 크기: 300MB
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량: 5백만 x 10% x 300MB = 150TB
- CDN 비용
  - 클라우드 CDN은 CDN에서 나가는 데이터의 양에 따라 과금
  - 아마존 클라우드프론트(CloudFront)를 CDN 솔루션으로 선택, 100% 트래픽이 미국에서 발생한다면 1GB당 $0.02의 요금이 발생. 문제를 단순화 하기 위해 비디오 스트리밍 비용만 계산
  - 따라서 매일 발생하는 요금은 5백만 x 5비디오 x 0.3GB x $0.02 = $150,000

<img width="849" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/26b74490-8825-417c-b008-98dd22f6c40c">

CDN을 통해 비디오를 서비스 하면 비용이 엄청나게 나온다.
이 비용을 줄이는 건 상세 설계를 하면서 알아 본다.

### 2단계 개략적 설계안 제시 및 동의 구하기

여기서 제시하는 설계안에서 CDN과 BLOB 스토리지의 경우는 클라우드 서비스를 이용한다.
이 서비스를 직접 구축하지 않는 이유는 다음과 같다.

- 시스템 설계 면접은 모든 걸 밑바닥부터 만드는 거소가 관계가 없다. 주어진 시간 안에 적절한 기술을 골라 설계를 마치는 것이 더 중요하다. 비디오 저장을 위해 BLOB 저장소를 쓴다는 사실만 언급해도 충분하며 어떻게 구현할지에 대한 상세 설계를 제시하는 건 오버(overkill)이다.
- 규모 확장이 쉬운 BLOG 저장소나 CDN을 만드는 것은 복잡하고 비용이 많이 든다. 넷플릭스는 아마존을 사용하고, 페이스북은 아카마이 CDN을 이용한다.

개략적으로 이 시스템은 다음 세 개 컴포넌트로 구성된다.

<img width="350" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/f05f30dc-d8d6-4ecb-b38a-946fce6cf9cf">

- 단말: 컴퓨터, 모바일, 스마트 TV를 통해 유튜브 시청
- CDN: 비디오는 CDN에 저장. CDN으로 부터 스트리밍이 이루어진다.
- API 서버: 비디오 스트리밍을 제외한 요청은 API 서버가 처리, 피드 추천, 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등

#### 비디오 업로드 절차

아래 그림은 비디오 업로드 절차의 개략적 설계안이다.

<img width="381" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/df0dd227-352d-423b-8991-efe0babeb436">

- 사용자: 컴퓨터, 모바일, 스마트 TV를 통해 유튜브 시청
- 로드밸런서: API 서버들에게 요청을 분산하는 역할
- API 서버: 비디오 스트리밍을 제외한 다른 모든 요청 처리
- 메타데이터 데이터베이스: 비디오의 메타데이터 보관. 샤딩과 다중화를 적용해서 성능 및 가용성 요구사항을 충족
- 메타데이터 캐시: 성능을 높이기 위해 비디오 메타데이터와 사용자 객체 캐시
- 원본 저장소: 원본 비디오를 보관할 대영 이진 파일 저장소(BLOB). BLOB 저장소는 이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템이다.
- 트랜스코딩 서버: 비디오 트랜스코딩은 비디오 인코딩이라 부르는 절차로, 비디오 포맷 등을 변환하는 절차이다. 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요
- 트랜스코딩 비디오 저장소: 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
- CDN: 비디오 캐시. 비디오 스트리밍은 CDN을 통해 이루어진다.
- 트랜스코딩 완료 큐: 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐
- 트랜스코딩 완료 핸들러: 트랜스코딩 완료 쿠에서 이벤트 데이터를 꺼내 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버

비디오가 업로드가 되면 아래 두 프로세스가 병렬처리가 된다.

a. 비디오 업로드
b. 비디오 메타데이터 갱신, 메타데이터는 비디오 URL, 크기, 해상도, 포맷, 사용자 정보가 포함된다.

##### 프로세스 a: 비디오 업로드

아래 그림은 비디오 업로드가 어떻게 이루어지는지 보여준다.

<img width="428" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/6591f9be-f085-4400-b3d0-0b1890b27aa8">

1. 비디오를 원본 저장소에 업로드
2. 트랜스코딩 서버가 원본 저장소에서 비디오를 가져와 트랜스 코딩 시작
3. 트랜스코딩이 완료되면 아래 두 절차가 병렬적으로 수행
  3a. 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드
  3b. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다.
    3a.1. 트랜스코딩이 끝난 비디오를 CDN에 올린다.
    3b.1 완료 핸들러가 이벤트 데이터를 큐에서 꺼낸다.
    3b.1.a, 3b.1.b. 완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신한다.
4. API 서버가 단말에게 비디오 업로드 완료 알림

##### 프로세스 b: 메타데이터 갱신

원본 저장소에 파일이 업로드되는 동안, 단말은 병렬저으로 비디오 메타데이터 갱신 요청을 API 서버로 보낸다.
메타데이터에는 파일 이름, 크기, 포맷 등의 정보가 있다. API 서버는 이 정보로 메타데이터 캐시와 데이터베이스를 업데이트한다.

<img width="196" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/6bb432ef-91d8-413b-b510-8409616b05ee">

#### 비디오 스트리밍 절차

유튜브에서 비디오 재생은 스트리밍이 바로 진행되며 비디오 다운로드 형식이 아니다. 다운로드는 비디오를 단말로 내려받는 걸 뜻하며, 스트리밍은 단말에 원격지의 비디오가 지속적으로 비디오 스트림을 전송 받아서 영상을 재생하는 걸 뜻한다.
여기서 스트리밍 프로토콜이라는 중요한 개념을 알아야 한다. 이건 비디오 스트리밍을 위해 데이터를 전송할 때 쓰는 표준화된 통신 방법이다. 스트리밍 프로토콜은 아래와 같은 것들이 있다.

- MPEG-DASH, MPEG는 Moving Picture Experts Group이고, DASH는 Dynamic Adaptive Streaming over HTTP이다.
- Apple HLS, HTTP Live Streaming
- Microsoft Smooth Streaming
- Adobe HTTP Dynamic Streaming, HDS 

프로토콜 별로 지원하는 비디오 인코딩이 다르고 플레이어가 다르다. 따라서 비디오 스트리밍 서비스를 설계할 때는 서비스의 용례에 맞는 프로토콜을 선택해야 한다.
비디오는 CDN에서 바로 스트리밍 되므로 사용자의 단말에 가장 가까운 CDN 에지 서버가 비디오 전송을 담당한다. 이렇게 하면 전송 지연이 아주 낮아지게 되고 아래 그림이 개략적 설계안이다.

<img width="185" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/b1092cb5-21f5-4a57-8162-4fb4381dde27">

### 3단계 상세 설계

개략적 설계에서 최적화 방안과 오류 처리 매커니즘을 추가해서 설계해 본다.

#### 비디오 트랜스코딩

비디오를 녹화하면 특정 포맷으로 저장한다. 이 비디오가 다른 단말에서 재생되려면 호환되는 비트레이트(bitrate)와 포맷으로 저장되어야 한다. 비트레이트는 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위다. 비트레이트가 높으면 일반적으로 고화질 비디오이다. 비트레이트가 높은 비디오 스트림을 재생하려면 높은 성능의 컴퓨팅 파워가 필요하고, 인터넷 속도도 빨라야 한다.
비디오 트랜스코딩은 아래 이유들로 인해 중요하다.

- 원본 비디오는 저장 공간을 많이 차지한다. 60 프레임의 HD 비디오는 수백 GB의 저장공간을 차지하게 될 수 있다.
- 많은 단말과 브라우저는 특정 종류의 비디오 포맷만 지원한다. 이런 호환성 문제를 해결하려면 하나의 비디오를 여러 포맷으로 인코딩 해 두면 좋다.
- 사용자의 네트워크 대역폭에 따라 저화질/고화질 비디오로 나눠서 전송한다.
- 단말의 네트워크 상황은 수시로 달라질 수 있으므로 비디오 화질을 자동으로 변경하거나 수동 변경할 수 있게 한다.

인코딩 포맷은 다양하지만 다음의 두 부분으로 구성되어 있다.

- 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 바구니이다. 컨테이너 포맷은 avi, mov, mp4 같은 파일 확장자를 통해 알 수 있다.
- 코덱: 비디오 화질을 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘이다. 주로 사용하는 비디오 코덱은 H.264, VP9, HEVC가 있다.

#### 유향 비순환 그래프(DAG) 모델

비디오를 트랜스코딩하는 건 컴퓨팅 자원을 많이 쓰고 시간도 오래 걸리는 작업이다.
거기다가 콘텐츠 창작자는 자기만의 비디오 프로세싱 요구사항을 가지고 있다.

- 워터마크 표시
- 섬네일 이미지 커스텀
- 선호하는 화질: 고화질/저화질

각각 다른 비디오 프로세싱 파이프라인을 지원하면서 병렬성을 높이기 위해 적절한 수준의 추상화를 도입해서 작업을 손수 정의할 수 있도록 해야 한다.
페이스북의 스트리밍 비디오 엔진은 유향 비순환 그래프(Directed Acyclic Graph) 프로그래밍 모델을 도입하여 작업을 단계별로 배열할 수 있고 해당 작업들이 순차 혹은 병렬로 실행될 수 있도록 하고 있다.
여기서도 이와 유사한 DAG 모델을 도입하여 유연성과 병렬성을 달성한다. 아래 그림이 DAG 모델이다.

<img width="447" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/3dfa496d-d6a0-4f67-bac7-f8d396c68055">

비디오에 적용되는 작업은 아래와 같다.

- 검사(inspection): 좋은 품질의 비디오인지, 손상은 없는지 확인
- 비디오 인코딩: 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩 하는 작업이다. 아래 그림이 예시이다.

<img width="331" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/d162856e-f05a-44c7-8ccb-6e27cd8cc1d9">

- 섬네일: 비디오에서 자동 추출된 이미지로 섬네일을 만든다.
- 워터마크: 비디오 식별정보를 이미지 위에 오버레이 형태로 띄워서 표시하는 작업이다.

#### 비디오 트랜스코딩 아키텍처

클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처를 아래와 같이 정의한다.

<img width="452" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/be7ed13a-f1fd-478b-8f46-66ce0c4ff95f"

##### 전처리기(Preprocessor)

<img width="448" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/51c78a77-d723-4ff9-bf6f-505f587ccb3d">

1. 비디오 분할(video splitting): 비디오 스크림을 GOP(Group of Pictures)라고 불리는 단위로 나눈다. GOP는 특정 순서로 배열된 프레임 그룹이다. 하나의 GOP는 독립 재생이 가능하고 몇 초 정도의 길이를 가진다. 오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 지원하지 않는데 전처리기가 비디오 분할을 대신 한다.
2. DAG 생성: 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만든다. 아래 그림은 두 개의 노드와 1개의 선으로 구성된 간단한 DAG이다. 이 DAG는 두 개의 설정 파일에서 생성된 것이다.

<img width="259" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ffa8be3b-51aa-4421-b7dc-f9b1e9978c68">

<img width="406" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/65e8450a-b19b-4fb0-a1a5-b719ae151719">

3. 데이터 캐시: 전처리기는 분할된 비디오의 캐시이다. 안정성을 높이기 위해 GOP와 메타데이터를 임시 저장소에 보관한다. 비디오 인코딩이 실패하면 시스템은 보관된 데이터를 활용해 인코딩을 재개한다.

##### DAG 스케줄러

<img width="455" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/84028305-3b8a-4d0e-ba3b-ea244348be16">

DAG 스케줄러는 DAG 그래프를 몇 개 단계로 분할한 다음 각각을 자원 관리자의 작업 큐에 넣는다.
아래 그림이 DAG 스케줄러의 예시이다.

<img width="473" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/65a6b068-4a0b-4fb4-8bf5-96f94707fcbc">

하나의 DAG 그래프를 2개 작업 단계로 쪼갠 사례다.
1단계에서는 비디오, 오디오, 메타데이터를 분리한다.
2단계에서는 해당 비디오 파일을 인코딩, 섬네일 추출, 오디오 인코딩을 한다.

##### 자원 관리자(Resource manager)

<img width="451" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/ebdf4373-39a4-4e6d-99b6-4a20434d7409">

자원 관리자는 자원 배분을 효과적으로 수행하는 역할을 한다.
아래 그림과 같이 세 개의 큐와 작업 스케줄러로 구성된다.

<img width="464" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/635b7f25-df7b-4692-be07-c5fd990a0547">

- 작업 큐(task queue): 실행할 작업이 보관되어 있는 우선순위 큐
- 작업 서버 큐(worker queue): 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
- 실행 큐(running queue): 현재 실행 중이 작업 및 작업 서버 정보가 보관되어 있는 큐
- 작업 스케줄러: 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할

자원 관리자는 다음과 같이 동작한다.

- 작업 관리자는 작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.
- 작업 관리자는 해당 작업을 실행하기 적합한 작업 서버를 고른다.
- 작업 스케줄러는 해당 작업 서버에게 작업 실행을 지시한다.
- 작업 스케줄러는 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣는다.
- 작업 스케줄러는 작업이 완료되면 해당 작업을 실행 큐에서 제거한다.

##### 작업 서버(Task workers)

<img width="451" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/44b883a4-64d1-4b39-830c-3e52cc1a43ec">

작업 서버는 DAG에 정의된 작업을 수행한다.
아래 그림처럼 작업 종류에 따라 작업 서버도 구분하여 관리한다.

<img width="213" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/86188bf6-4c47-459d-987a-7979cdf5a84b">

##### 임시 저장소(Temporary storage)

<img width="450" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/faf5375e-1d3d-4188-b00d-277ab28a7920">

임시 저장소는 어떤 시스템을 선택하느냐에 따라 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 달라진다.
메타데이터는 작업 서버가 빈번히 참조하는 정보이고 크기도 작아서 메모리에 캐시해 두면 좋다.
비디오/오디오 데이터는 BLOB 저장소를 쓰는게 좋다.
임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.

##### 인코딩된 비디오(Encoded video)

<img width="457" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/35c6999e-7d77-41ec-8a53-86283950c31c">

인코딩 파이프라인의 최종 결과물로 funny_720p.mp4와 같은 이름을 가진다.

#### 시스템 최적화

이제는 속도, 안정성, 비용 측면에서 최적화를 고려해 본다.

##### 속도 최적화: 비디오 병렬 업로드

비디오 전부를 한 번의 업로드로 올리는 건 비효율적이다. 하나의 비디오는 아래 그림처럼 작은 GOP로 분할할 수 있다.

<img width="451" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/77df36e6-9aa6-4507-b712-e4963a62cad9">

이렇게 분할되어 있는 GOP를 병렬로 업로드 하면 일부가 실패한다고 해도 빠르게 업로드가 가능하다.
따라서 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 아래 그림처럼 업로드 속도를 높일 수 있다.

<img width="456" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/04685f13-8723-4ffd-a83f-ddc149dda97a">

##### 속도 최적화: 업로드 센터를 사용자 근거리에 지정

또 다른 방법으로 아래 그림과 같이 업로드 센터를 여러 곳에 둔다.
여기서는 CDN을 업로드 센터로 이용한다.

<img width="442" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/374dfcbc-365d-4ca6-a999-e614117270a3">

##### 속도 최적화: 모든 절차를 병렬화

낮은 응답지연을 달성하기에는 어려우므로 느슨하게 결합된 시스템을 만들어서 병렬성을 높이는 방법을 쓴다.
그러려면 설계안을 조금 변경해야 하는데, 비디오를 원본 저장소에서 CDN으로 옮기는 절차를 아래 그림과 같이 진행한다.

<img width="456" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/a8f48987-2eec-44f3-9fca-6b1360beedc2">

어떤 단계가 이전 단계의 결과를 입력으로 받는 의존성을 가지고 있으면 병렬성을 높이기 어렵다.
이런 결합도를 낮추기 위해서 아래와 같이 메시지 큐를 도입한다.

<img width="461" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/c872edba-c6b3-4bfb-82dc-ae265b331bbd">

- 메시지 큐를 도입하기 전에 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야 한다.
- 메시지 큐를 도입한 후, 인코딩 모듈은 다운로드 모듈의 작업을 기다리지 않아도 된다. 메시지 큐에 보관된 이벤트 각각을 인코딩 모듈은 병렬적으로 처리할 수 있다.

##### 안정성 최적화: 미리 사인된 업로드 URL

허가받은(authorized) 사용자만 비디오 업로드를 할 수 있도록 미리 사인된(pre-signed) 업로드 URL을 이용한다.

<img width="411" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/47328fc0-3340-4989-8309-59b29dfc5257">

업로드 절차는 다음과 같이 업데이트 된다.

1. 클라이언트는 HTTP 서버에 POST 요청을 해서 미리 사인된 URL을 받는다. 미리 사인된 URL이라는 용어는 아마존 S3에서 쓰이는 용어다. 마이크로소프트 애저의 경우는 접근 공유 시그니처(Shared Access Signature) 라고 부른다.
2. API 서버는 미리 사인된 URL을 응답 값으로 준다.
3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드 한다.

##### 안정성 최적화: 비디오 보호

비디오 원본 도난 우려 때문에 비디오를 인터넷에 업로드하는 걸 꺼리는 사용자가 있다.
비디오 저작권 보호를 위해 세 가지 옵션을 선택한다.

- 디지털 저작권 관리(DRM: Digial Rights Management) 시스템 도입: Apple FiarPlay, Google Widevine, Microsoft PlayReady
- AES 암호화: 비디오를 암호화 한 후에 접근 권한을 설정한다. 암호화된 비디오는 재생 시에만 복호화한다. 허락된 사용자만 암호화된 비디오를 시청할 수 있다.
- 워터마크: 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 만든다. 회사 로고나 이름 등을 사용한다.

##### 비용 최적화

CDN은 데이터 크기가 클수록 비용이 올라가므로 비용을 낮춰야 한다.
연구 결과에 따르면, 유튜브의 비디오 스트리밍은 롱테일 분포를 따른다. 인기있는 비디오는 빈번히 재생되고 나머지는 거의 보는 사람이 없다. 여기에 착안해서 몇 가지 최적화를 시도해 볼 수 있다.

1. 인기 비디오는 CDN을 통해 재생하되 다른 비디오는 비디오 서버를 통해 재생한다.

<img width="322" alt="image" src="https://github.com/jongfeel/BookReview/assets/17442457/f322c6e7-02e8-4792-b06e-12c166521885">

2. 인기가 별로 없는 비디오는 인코딩도 필요 없을 수 있다. 짧은 비디오는 필요할 때 인코딩 한다.
3. 특정 지역에서만 인기 있는 비디오의 경우 다른 지역에 옮길 필요가 없다.
4. CDN을 직접 구축한 후에 인터넷 서비스 제공자(ISP)와 제휴한다. CDN을 직접 구축하는 것은 대규모 스트리밍 사업자 정도가 진행할 수 있는 초대형 프로젝트이다. ISP는 Comcast, AT&T, Verizon 등이 있다. 이들과 제휴하면 사용자 경험을 향상시킬 수 있고 인터넷 사용 비용을 낮출 수 있다.

최적화는 콘텐츠 인기도, 이용 패턴, 비디오 크기 등의 데이터에 근거하므로 최적화를 시도하기 전에 시청 패턴을 분석하는 것은 중요한 일이다.

#### 오류 처리

장애를 아주 잘 감내하는(highly fault-tolerant) 시스템을 만들려면 오류를 빠르게 처리하고 복구해야 한다.
시스템은 회복 가능 오류와 회복 불가능 오류가 있다.

- 회복 가능 오류(recoverable error): 특정 비디오 세그먼트를 트랜스코딩하다가 실패하는 오류는 회복 가능하다. 이런 오류는 몇 번 재시도 하면 해결되는데, 계속 실패하고 복구가 어렵다고 판단되면 클라이언트에게 오류 코드를 반환해야 한다.
- 회복 불가능 오류(non-recoverable error): 비디오 포맷이 잘못되었거나 하는 회복 불가능한 오류가 발견되면 시스템은 작업을 중단하고 클라이언트에 오류 코드를 반환한다.

시스템 컴포넌트에 발생할 수 있는 오류의 해결 방법은 아래와 같이 요약할 수 있다.

- 업로드 오류: 몇 번 재시도 한다.
- 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못한다면 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
- 트랜스코딩 오류: 재시도 한다.
- 전처리 오류: DAG 그래프를 재생성한다.
- DAG 스케줄러 오류: 작업을 다시 스케줄링한다.
- 자원 관리자 큐에 장애 발생: 사본을 이용한다.
- 작업 서버 장애: 다른 서버에서 해당 작업을 재시도한다.
- API 서버 장애: API 서버는 무상태 서버이므로 신규 요청은 다른 API 서버로 우회해서 요청한다.
- 메타데이터 캐시 서버 장애: 데이터는 다중화되어 있으므로 다른 노드에서 데이터를 여전히 가져올 수 있다. 장애가 난 캐시 서버는 새로운 것으로 교체한다.
- 메타데이터 데이터베이스 서버 장애
  - 주 서버가 죽었다면 부 서버 가운데 하나를 주 서버로 교체한다.
  - 부 서버가 죽었다면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새것으로 교체한다.

### 4단계 마무리

설계를 마친 후에 면접관과 다음과 같은 내용을 더 논의해 볼 수 있다.

- API 계층의 규모 확장성 확보 방안: API 서버는 무상태 서버이므로 수평적 규모 확장이 가능하다.
- 데이터베이스 계층의 규모 확장성 확보 방안: 데이터베이스 다중화화 샤딩
- 라이브 스트리밍(live streaming): 라이브 스트리밍은 비디오를 실시간으로 녹화하고 방송하는 절차이다. 여기서 설계한 시스템은 라이브 스트리밍용은 아니지만 이 둘의 차이점은 다음과 같다.
  - 라이브 스트리밍의 경우에는 응답지연이 좀 더 낮아야 한다. 따라서 스트리밍 프로토콜 선정에 유의해야 한다.
  - 라이브 스트리밍의 경우 병렬화 필요성은 떨어지는데, 작은 단위의 데이터를 실시간으로 빨리 처리해야 하기 때문이다.
  - 라이브 스트리밍의 경우 오류 처리 방법을 다르게 해야 한다. 처리 복구하는데 시간이 오래 걸리는 방법은 사용하면 안된다.
- 비디오 삭제(takedown): 저작권 위반, 선정적, 불법적인 비디오의 경우에는 내려야 한다. 내릴 비디오는 업로드 과정에서 식별할 수 있지만 사용자 신고를 통해 판별할 수도 있다.