# chapter 15  구글 드라이브 설계
강한 일관성 모델을 기본으로 지원해야 한다

## 블록 저장소 서버
- 파일 블록을 클라우드 저장소에 업로드 하는 서버
- 클라우드 환경에서 데이터 파일을 저장하는 기술
- 여러개의 블록으로 나눠 저장
- 각 블록에는 고유한 해시값 할당
- 해시값은 메타데이터 데이터베이스에 저장

- 업데이트 일어날 때마다 전체파일을 서버로 보내지 않고 최적화 하는 방법 두가지
  - 델타 동기화: 파일이 수정되면 전체 파일 수정 대신 수정이 일어난 블록만 동기화
  - 압축: 블록단위로 압축
- 작은 블록으로 분할 -> 각 블록 압축 -> 암호화 -> 클라우드 저장소로 보낸다
- 따라서, 네트웤크 대역폭 사용량을 절감할 수 있다

## 클라우드 저장소
- 파일은 블록 단위로 나눠져 클라우드 저장소에 보관

## 아카이빙 저장소
- 오랫동안 사용되지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템

## 메타데이터 데이터베이스
- 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리
- 실제 파일은 클라우드에 보관

## 오프라인 사용자 백업 큐
- 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때 해당 정보를 큐에 두어 나중에 접속했을 때 동기화할 수 있도록 함

## 알림 서비스
- 파일의 일관성 유지를 위해
- 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려서 충돌 가능성을 줄이기 위해
- 롱폴링 채택
  - 양방향 통신이 필요하지 않기때문(웹소켓 불필요)
  - 롱 폴링 연결을 알림서버와 유지하다가 특정 파일에 대한 변경을 감지하면 연결을 끊는다 -> 메타데이터 서버와 연결해 파일 최신 내역 다운로드

## 저장소 공간 절약
- 이력보존, 안정성 보장을 위해 파일의 여러버전을 여러 데이터 센터에 보관
- 너무 자주 백업하면 저장용량 빨리 소진되므로 방법 3가지
  - 중복 제거: 해시값 비교하여 판단
  - 지능적 백업전략 도입: 한도 설정하여 제일 오래된 버전을 버리고, 중요한 버전만 보관
  - 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다

## 장애처리
### 로드밸런서 장애
- 로드밸런서 장애 발생할 경우 부로드밸런서가 트래픽 이어 받음
- 로드밸런서끼리는 박동 신호를 주기적으로 보내 상태 보니터링

### 블록 저장소 서버 장애
- 장애 발생하면 다른 서버가 작업 이어 받음

### 클라우드 저장소 장애
- s3버킷은 여러지역에 다중화할 수 있으므로 한 지역에서 장애 발생하면 다른 지역에서 가져오면 됨

### 메타데이터 캐시 장애
- 다중화 - 다른 노드에서 데이터 가져올 수 있고, 새 서버로 교체하면 됨

### 메타데이터 데이터베이스 장애
- 주 데이터베이스 서버 장애: 부 데이터베이스 서버를 주 데이터베이스로 바꾸고, 부 데이터베이스 하나 새로 추가
- 부 데이터베이스 서버 장애: 다른 부 데이터베이스 서버가 읽기 연산 처리, 그동안 장애 서버 교체

### 알림 서비스 장애
- 모든 사용자가 알림서버와 롱 폴링 연결을 하나씩 유지하고 있다
- 그래서 한 대의 서버에 장애가 발생하면 많은 사용자가 다시 롱폴링 연결을 만들어야 함
- 그래서 한 대의 서버에 한꺼번에 많은 사용자가 롱 폴링 연결을 하지 않도록 해야함
- 롱 폴링 연결 복구는 느리기 때문

### 오프라인 사용자 백업 큐 장애
- 큐에 장애가 발생하면 구독 중인 클라이언트 들은 백업 큐로 구독 관계를 재설정 해야한다


# 느낀점
구글 클라우드 설계에 대해 공부하면서, 문득 구글 독스 와 같은 하나의 데이터를 여러 사용자가 동시에 수정하는 것은 어떻게 설계할까 궁금해졌습니다
책을 다시 복습하면서 구글 독스 설계도 공부해볼 예정입니다

# 논의주제
특정 구글 드라이브의 url을 다른 사용자에게 보내주면 그 사용자도 저장소에 접근하여 데이터를 다운받을 수 있는데, 미리사인된 url을 생성해서 주기때문인가요??
해당 url이 외부로 노출되지 않고, 공유한 사람에게만 접근할 수 있도록 어떻게 설계한 것일까요?